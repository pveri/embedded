/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define IPR_FIELDS 4
#define IPR_FIELD_WIDTH 8

#define IPR_BASE 0xE000E400 //Interrupt Priority Registers
#define ISPR_BASE 0XE000E200U
#define ISER_BASE 0xE000E100U
#define ISPR1 ISPR_BASE+4

#define ADC_IRQNO 18
#define USART2_IRQNO 38
#define USART3_IRQNO 39
#define REGISTER_SIZE 32


uint8_t parallel = 0;
uint8_t enable_nesting = 0;
// The number of priority levels depends on the Interrupt Priority Register implementation (vendor specific)
// The STM32F4 MCU has 16 priority levels.

// Priority Grouping: If two interrupt requests are encountered at the same time, the interrupt with the higher preempt priority
// will be serviced first
// When two interrupts with the same preempt priority are encountered at the same time, the interrupt with the
// higher sub-priority will be serviced first
void configure_priority(uint8_t irqNo, uint8_t priority) {
	//1.) Find out which IPR register to use
	uint8_t iprIdx = irqNo/ IPR_FIELDS;

	uint32_t * ipRegister = (uint32_t*)(IPR_BASE)+(iprIdx);

	// 2. Calculate Bit position
	uint8_t position = (irqNo % IPR_FIELDS) * IPR_FIELD_WIDTH;

	// 3. Configure the priority
    *ipRegister &= ~(0xFF << position); // Clear
    *ipRegister |= (priority << position); // Set

}


void set_pend(uint8_t irq) {
	uint8_t isprIdx = irq / 32;
	uint32_t * irqIspr = (uint32_t*)(ISPR_BASE)+(isprIdx);
	*irqIspr |= (1 << (irq % REGISTER_SIZE));
}

void enable_isr(uint8_t irq) {
	uint8_t iserIdx = irq / 32;
	uint32_t * irqIser = (uint32_t*)(ISER_BASE)+(iserIdx);
	*irqIser |= (1 << (irq % REGISTER_SIZE));
}

int main(void)
{
	// NVIC - Nested Vector Interrupt Controller
	// Handles interrupts, preempting based on priority

	// Manually pend the pending bit for the USART3 IRQ number in NVIC
	// Normally this is done automatically when a mapped peripheral issues an Interrupt request

	// Use ISPR (Interrupt Set Pending Register)  8x32 bit registers, IRQ39 will use the second NVIC_ISPR register 1
	// NVIC_ISPR0 lives at 0XE000E200
     uint32_t * irqIspr = ((uint32_t*)0XE000E200); // Address of first ISPR register
     irqIspr++; //IRQ39 lives at the next register
     // Find the bit field corresponding to this IRQ handler in NVIC register
     *irqIspr |= (1 << (USART3_IRQNO % REGISTER_SIZE)); // Set the bit in this register

	// Enable the USART3 IRQ number in NVIC
    // ISER registers: there are 8, they are 32 bits wide, and start at address 0xE000E100
    uint32_t * irqIser = (uint32_t*)0xE000E100;
    irqIser++;
    *irqIser |= (1 << (USART3_IRQNO % REGISTER_SIZE));

    // Interrupt priority registers are part of the NVIC register set. NVIC_IPR0-NVIC_IPR59. Each interrupt is allocated
    // 8 bits in each register, and each register has 4 Interrupt priority fields.

    // Priority grouping exercise
    configure_priority(ADC_IRQNO, 0x80);
    configure_priority(USART2_IRQNO, 0x80);

    set_pend(ADC_IRQNO);
    set_pend(USART2_IRQNO);
    enable_isr(ADC_IRQNO);
    enable_isr(USART2_IRQNO);

    set_pend(USART2_IRQNO);
    enable_isr(USART2_IRQNO);

    /* Loop forever */
	for(;;);
}

// USART3 ISR
void USART3_IRQHandler(void) {
	uint32_t * irqIspr = ((uint32_t*)0XE000E204);
	printf("In USART3 Interrupt, pending state should be 0\n Value is:%d\n", *irqIspr);
	//uint32_t * irqIser = (uint32_t*)0xE000E104;
	//*irqIser &= ~(1 << (USART2_IRQNO % REGISTER_SIZE));
}

void USART2_IRQHandler(void) {
	printf("In USART2_IRQHandler");
	uint32_t i = 0;
	if (parallel) {
		set_pend(ADC_IRQNO);
		enable_isr(ADC_IRQNO);
		while (1 && parallel) {
			if (enable_nesting) {
				configure_priority(ADC_IRQNO, 0x70);
			}
			if (i++ > 2000000) {
				enable_nesting = 1;
			}
		}
	}
	parallel = 1;
}

void ADC_IRQHandler(void) {
	printf("In ADC handler\n");
	if (parallel) {
		parallel = 0;
	}
}
